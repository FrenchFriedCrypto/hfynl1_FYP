<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cipher Decoder</title>
  <style>
    body {
      font-family: monospace;
      margin: 20px;
    }
    #tablesContainer {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }
    table {
      border-collapse: collapse;
      min-width: 120px;
      margin-bottom: 20px;
    }
    table, th, td {
      border: 1px solid #ccc;
      padding: 5px 10px;
      text-align: center;
    }
    input {
      width: 30px;
      text-align: center;
      font-size: 16px;
    }
    pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      background-color: #f9f9f9;
      padding: 10px;
      border: 1px solid #ddd;
    }
    h1, h2, h3 {
      margin-bottom: 10px;
    }
    #copyKeyButton {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>Cipher Decoder</h1>

  <h2>Ciphertext</h2>
  <pre id="ciphertext">
votfgkvyowodvmxztrylzuvhtvqgyerggokzyugotgygltfghyvslglhvrytyvvkztmvtfgywodfzuhzxtngugzyxvmwkpywxvokgotzoltfgvoxgtvmyfgrkztwxkfzltzjgotfgwytvnnugtxfgygkzwogllwdowmwglhvkpvxglzolwolwxprtzqnuygdznzxxwxtglqufgypfuxwhwzoxfgkzlgfgyszupzxttfgcrldgxvmmwhwznxzolxpghtztvyxzolzppyvzhfgltfgtfyvogtfztxtvvlfznmszuznvodtfgnvodozyyvshfzkqgykzyufzlzxxrkgltfzttfgtfyvogszxzdgxtrygvmygxpghttvszylfgyqrtxfgszxkwxtzjgotfgtfyvogxukqvnwagltfgzqxgoterggognwazqgtfkzyuxgogkuzolpyvxghrtvykzyuszxdgotnudrwlglzszumyvktfgtfyvogzoltvszyltfgvppvxwtgxwlgvmtfgyvvktvtfglgmgolzotxxgztzhywkxvoignigthfzwykzyuerggovmxhvtxszxvotywznmvytygzxvoxfgfzlqggozhhrxglvmpnvttwodtvzxxzxxwoztgerggognwazqgtfwovylgytvtzjgtfggodnwxfhyvsomvyfgyxgnmxwymyzohwxsznxwodfzkgnwazqgtfxpywohwpznxghygtzyufzlznygzluzyygxtgltfgvtfgyhvoxpwyztvyxgbtyzhtglhvomgxxwvoxzolgbghrtgltfgkovsfgpnzoogltvpyvigtfztkzyuszxzttfgfgzytvmtfgpnvtzolszxtfgygmvyggerznnutvqnzkgzolgerznnulgxgyiwodvmlgztfsznxwodfzkjogstfztqgmvygfghvrnlfzigkzyugbghrtglfgsvrnlfzigtvhvoiwohgerggognwazqgtfvmfgydrwntzntfvrdfgnwazqgtflgxpwxglkzyuxfgfzlxgigyznygzxvoxmvyqgwodygnrhtzottvxggfgyprttvlgztfmwyxtkzyuszxzxhvttwxferggozolkzouergxtwvoglsfgtfgyzogodnwxfhvrytfzltfgzrtfvywtutvgbghrtgzmvygwdofgzlvmxtztgxghvolgbghrtwodkzyukwdftgxtzqnwxfzozsjszylpyghglgotwmtfgxtztgwxznnvsgltvjwnnvogerggotfgopgyfzpxygqgnxkwdftfzigmgsgyygxgyiztwvoxzqvrtjwnnwodzovtfgyozkgnugnwazqgtftfwylgnwazqgtfzolkzyusgyghvrxwoxzoltfgwyqnvvltwgkzlggnwazqgtfznntfgkvygxergzkwxfzqvrtvylgywodtfggbghrtwvowoxfvytgnwazqgtfsvrnlxzohtwvokzyuxgbghrtwvovonuwmsznxwodfzkhvrnlpyvigqguvolzoufwotvmlvrqttfztxfgfzlqggopzytvmtfgzxxzxxwoztwvopnvttfghvoxpwyztvyxsgygzdyvrpvmuvrodgodnwxfhztfvnwhovqngkgowotgotvoygkviwodgnwazqgtfzpyvtgxtzotzolygpnzhwodfgyswtfkzyuzmgnnvshztfvnwhwtszxzppzygottvtfghvryttfztkzyuszxzmwdrygfgzlmvytfghvoxpwyztvyxqrtwtszxovthngzytfztxfgfzldwigofgyqngxxwodtvtfghvoxpwyzhuwomzhtkzyufzlzrtfvywagltfgpnvttfghfznngodgmvysznxwodfzkszxtvlgkvoxtyztgzhngzynwojqgtsggokzyuzoltfgpnvttgyxvotfgkvyowodvmfgytywznkzyuxztznvogwotfglvhjlygxxglwoxvyyvsmrnqnzhjignigtwohzxgxvmtygzxvotfgzhhrxglszxmvyqwllgohvroxgnzolszxovtpgykwttgltvhznnswtogxxgxkzyuszxovtgigoznnvsglxghygtzywgxtvfgnpfgypygpzygfgyhzxgfvsgigyfgypnwdftszxovtfvpgngxxqghzrxgxfgfzlqggohzygmrntvgoxrygtfztznnfgyhvyygxpvolgohgswtftfghvoxpwyztvyxfzlqggosywttgowohwpfgytfghwpfgytryoglfgysvylxwotvzkgzowodngxxxgywgxvmxukqvnxzolkzyuqgnwgigltfztgigowmsznxwodfzkfzlhzptrygltfgngttgyxfghvrnlfzigovwlgzvmtfgkgzowodvmtfgsvylxswtfwotfgkwmtfgwyhvotgotxsgygzkuxtgyutfgotfgngttgyxhvrnlovtqgrxglzxgiwlgohgzdzwoxtfgyfvsgigytfwxznnlgpgolglvotfgzxxrkptwvotfztfgyhwpfgyfzlovtqggoqyvjgoromvytroztgnumvykzyusznxwodfzkszxovtkgygnupywohwpznxghygtzyuqrtznxvgodnzolxxpukzxtgyfgfzlwotgyhgptglkzyuxngttgyxtvtfgpnvttgyxzolfgjogsgbzhtnusfvkwdftqghzpzqngvmlghwpfgywodtfgktfvkzxpfgnwppgxszxtfgoztwvoxmvygkvxtgbpgytvoqygzjwodhvlgxzolmvyugzyxfgfzlqggolghwpfgywodtfgkgxxzdgxvmtfvxgsfvpnvttglzdzwoxterggognwazqgtftfgygqupyviwlwodtfggiwlgohgogglgltvhvolgkotfgkwmfghvrnllghwpfgytfgwohywkwoztwodngttgyxqgtsggokzyuzoltfghvoxpwyztvyxtfgofgylgztfsvrnlgqgwogiwtzqngvotfgvtfgyfzolwmkzyuxhwpfgyszxxtyvodgovrdftvhvohgznfgyxghygtxtfgotfgygszxzhfzohgtfztxfgkwdftxryiwigovtmvytfgmwyxttwkgznwmgfrodvotfgxtygodtfvmzhwpfgy
  </pre>

  <h2>Frequency of Characters in Ciphertext</h2>
  <canvas id="frequencyChart" width="600" height="400"></canvas>

  <h2>N窶組ram Analysis</h2>
  <h3>Top 20 1窶組rams</h3>
  <table id="oneGramTable">
    <thead>
      <tr>
        <th>Gram</th>
        <th>Frequency</th>
        <th>Deciphered</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <h3>Top 20 2窶組rams</h3>
  <table id="twoGramTable">
    <thead>
      <tr>
        <th>Gram</th>
        <th>Frequency</th>
        <th>Deciphered</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <h3>Top 20 3窶組rams</h3>
  <table id="threeGramTable">
    <thead>
      <tr>
        <th>Gram</th>
        <th>Frequency</th>
        <th>Deciphered</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <h2>Substitution Table</h2>
  <div id="tablesContainer">
    <!-- First Subtable: letters a-i -->
    <table id="subTable1">
      <thead>
        <tr>
          <th>Cipher</th>
          <th>Decipher</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <!-- Second Subtable: letters j-r -->
    <table id="subTable2">
      <thead>
        <tr>
          <th>Cipher</th>
          <th>Decipher</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <!-- Third Subtable: letters s-z -->
    <table id="subTable3">
      <thead>
        <tr>
          <th>Cipher</th>
          <th>Decipher</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <h2>Decoded Output</h2>
  <pre id="decodedOutput"></pre>

  <!-- Button to copy the encryption key -->
  <button id="copyKeyButton">Copy Encryption Key</button>

  <script>
    // Retrieve the ciphertext.
    const ciphertext = document.getElementById('ciphertext').textContent;

    // Predefined mapping values that you've already determined.
    const presetMapping = {
      a: '',
      b: '',
      c: '',
      d: '',
      e: '',
      f: 'h',
      g: 'e',
      h: '',
      i: '',
      j: '',
      k: '',
      l: '',
      m: '',
      n: '',
      o: '',
      p: '',
      q: '',
      r: '',
      s: '',
      t: 't',
      u: '',
      v: 'o',
      w: '',
      x: '',
      y: '',
      z: 'a'
    };

    // Attempt to load a saved mapping from localStorage.
    const storedMapping = localStorage.getItem('substitutionMapping');
    const mappingData = storedMapping ? JSON.parse(storedMapping) : presetMapping;

    // Define letter groups for the three substitution tables.
    const groups = [
      'abcdefghi'.split(''),
      'jklmnopqr'.split(''),
      'stuvwxyz'.split('')
    ];

    // Function to create a row for each letter in the substitution table.
    function createRow(letter) {
      const row = document.createElement('tr');

      // Cipher letter cell.
      const cell1 = document.createElement('td');
      cell1.textContent = letter;
      row.appendChild(cell1);

      // Input cell for the decipher character.
      const cell2 = document.createElement('td');
      const input = document.createElement('input');
      input.type = 'text';
      input.maxLength = 1;
      input.dataset.letter = letter;
      // Set input value and placeholder from the saved/preset mapping.
      input.value = mappingData[letter] ? mappingData[letter] : '';
      input.placeholder = mappingData[letter] ? mappingData[letter] : '';

      // Update decoded output, save progress, and update n-gram tables on change.
      input.addEventListener('input', function() {
        updateDecodedOutput();
        saveMapping();
        updateNGramTables();
      });
      cell2.appendChild(input);
      row.appendChild(cell2);

      return row;
    }

    // Populate each substitution subtable.
    groups.forEach((group, index) => {
      const tbody = document.querySelector(`#subTable${index+1} tbody`);
      group.forEach(letter => {
        tbody.appendChild(createRow(letter));
      });
    });

    // Update the decoded output based on current substitutions.
    function updateDecodedOutput() {
      const currentMapping = getCurrentMapping();
      let output = "";
      for (let char of ciphertext) {
        output += currentMapping[char] ? currentMapping[char] : char;
      }
      document.getElementById('decodedOutput').textContent = output;
    }

    // Save current substitution mapping to localStorage.
    function saveMapping() {
      const currentMapping = {};
      document.querySelectorAll('input[data-letter]').forEach(input => {
        currentMapping[input.dataset.letter] = input.value.trim();
      });
      localStorage.setItem('substitutionMapping', JSON.stringify(currentMapping));
    }

    // Get the current mapping from the substitution inputs.
    function getCurrentMapping() {
      const currentMapping = {};
      document.querySelectorAll('input[data-letter]').forEach(input => {
        const letter = input.dataset.letter;
        const val = input.value.trim();
        if (val) {
          currentMapping[letter] = val.charAt(0).toUpperCase();
        }
      });
      return currentMapping;
    }

    // Update frequency chart of ciphertext.
    function updateFrequencyChart() {
      const freq = {};
      for (let letter of "abcdefghijklmnopqrstuvwxyz") {
        freq[letter] = 0;
      }
      for (let char of ciphertext) {
        if (char >= 'a' && char <= 'z') {
          freq[char]++;
        }
      }
      const canvas = document.getElementById('frequencyChart');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const maxFreq = Math.max(...Object.values(freq));
      const chartHeight = canvas.height - 50;
      const barWidth = (canvas.width - 40) / 26;
      let i = 0;
      for (let letter of "abcdefghijklmnopqrstuvwxyz") {
        const count = freq[letter];
        const barHeight = (count / maxFreq) * chartHeight;
        const x = 20 + i * barWidth;
        const y = canvas.height - barHeight - 20;
        ctx.fillStyle = '#4285F4';
        ctx.fillRect(x, y, barWidth - 2, barHeight);
        ctx.fillStyle = '#000';
        ctx.font = "12px sans-serif";
        ctx.textAlign = 'center';
        ctx.fillText(count, x + barWidth/2 - 1, y - 5);
        ctx.fillText(letter, x + barWidth/2 - 1, canvas.height - 5);
        i++;
      }
    }

    // Decode a given string (n-gram) using the current mapping.
    function decodeGram(gram, mapping) {
      let decoded = "";
      for (let char of gram) {
        decoded += mapping[char] ? mapping[char] : char;
      }
      return decoded;
    }

    // Compute n-gram frequencies.
    function getNGrams(n) {
      const freq = {};
      for (let i = 0; i <= ciphertext.length - n; i++) {
        const gram = ciphertext.substring(i, i + n);
        freq[gram] = (freq[gram] || 0) + 1;
      }
      return freq;
    }

    // Update a specific n-gram table with an extra column for deciphered n-gram.
    function updateNGramTable(n, tableId) {
      const freq = getNGrams(n);
      const arr = Object.entries(freq);
      // Sort descending by frequency.
      arr.sort((a, b) => b[1] - a[1]);
      const tbody = document.querySelector(`#${tableId} tbody`);
      tbody.innerHTML = '';
      const currentMapping = getCurrentMapping();
      for (let i = 0; i < Math.min(20, arr.length); i++) {
        const row = document.createElement('tr');

        // Original n-gram cell.
        const cell1 = document.createElement('td');
        cell1.textContent = arr[i][0];
        row.appendChild(cell1);

        // Frequency cell.
        const cell2 = document.createElement('td');
        cell2.textContent = arr[i][1];
        row.appendChild(cell2);

        // Deciphered n-gram cell.
        const cell3 = document.createElement('td');
        const deciphered = decodeGram(arr[i][0], currentMapping);
        cell3.textContent = deciphered;
        // If every letter in this n-gram is deciphered, set background to bright green.
        let allMapped = true;
        for (let char of arr[i][0]) {
          if (!(char in currentMapping)) {
            allMapped = false;
            break;
          }
        }
        if (allMapped) {
          cell3.style.backgroundColor = '#00FF00';
        }
        row.appendChild(cell3);

        tbody.appendChild(row);
      }
    }

    // Update all n-gram tables.
    function updateNGramTables() {
      updateNGramTable(1, 'oneGramTable');
      updateNGramTable(2, 'twoGramTable');
      updateNGramTable(3, 'threeGramTable');
    }

    // Copy the current encryption key (substitution mapping) to clipboard.
    function copyEncryptionKey() {
      const currentMapping = getCurrentMapping();
      let keyStr = "Encryption Key:\n";
      for (let letter of "abcdefghijklmnopqrstuvwxyz") {
        keyStr += letter + " -> " + (currentMapping[letter] || "") + "\n";
      }
      navigator.clipboard.writeText(keyStr)
        .then(() => {
          alert("Encryption key copied to clipboard!");
        })
        .catch(() => {
          alert("Failed to copy encryption key.");
        });
    }

    // Attach event listener to the button.
    document.getElementById("copyKeyButton").addEventListener("click", copyEncryptionKey);

    // Initialize all components.
    updateDecodedOutput();
    updateFrequencyChart();
    updateNGramTables();
  </script>
</body>
</html>
